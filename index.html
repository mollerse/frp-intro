<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Intro til FRP</title>

        <link rel="stylesheet" href="./css/reveal.min.css">
        <link rel="stylesheet" href="./css/theme/night.css">
        <link rel="stylesheet" href="./css/main.css">
        <link rel="stylesheet" href="./css/vote-example.css">
        <link rel="stylesheet" href="./css/monokai-sublime.css">


        <script type="text/javascript" src="js/jquery.js"></script>
        <script type="text/javascript" src="js/bacon.js"></script>
        <script type="text/javascript" src="/socket.io/socket.io.js"></script>
    </head>

    <body>

        <div class="reveal">

            <div class="slides">

                <section>
                    <h2>Introduksjon til Functional Reactive Programming (FRP)</h2>
                    <p>BEKK Fagdag</p>
                    <p>Stian Veum Møllersen / <a href="http://twitter.com/mollerse">@mollerse</a></p>
                    <p>Mikael Brevik / <a href="http://twitter.com/mikaelbrevik">@mikaelbrevik</a></p>
                    <p><a href="http://open.bekk.no">open.bekk.no</a></p>
                </section>

                <section>
                    <h2>Agenda</h2>
                    <ol>
                        <li>Teoretisk introduksjon</li>
                        <li>FRP i front-end</li>
                        <li>Bacon.js</li>
                        <li>Praktiske eksempler og demo</li>
                    </ol>
                </section>

                <section>
                    <h3>Hva er Functional Reactive Programming?</h3>
                    <p>Kombinasjonen mellom to paradigmer:</p>
                    <ol>
                    <li>Funksjonell programmering</li>
                    <li>Reaktiv programmering</li>
                    </ol>
                </section>

                <section>
                    <section><h2>Funksjonell programmering</h2></section>
                    <section>
                        <h3>En deklarativ programmeringsparadigme med funksjoner i fokus.</h3>
                        <h4>Unngår tilstander og mutable objekter.</h4>
                    </section>
                    <section>
                        <h4>Deklarativ programmering forklarer hva som skjer.</h4>
                        <h4>Imperativ programmering forklarer hvordan det skal skje!</h4>
                    </section>
                    <section>
                        <h3>Unngår uønskede bieffekter</h3>
                    </section>
                    <section>
                        <h3>Vanlig med bruk av blant annet <code>map</code>, <code>reduce</code> og <code>filter</code>.</h3>
                        <h4>Eksempler på språk kan være Lisp, Haskell, Scala, men også JavaScript</h4>
                    </section>
                </section>
                <section>
                    <section><h2>Reaktiv programmering</h2></section>
                    <section>
                        <h3>Kan beskrives som en metode for å holde systemet kontinuerlig oppdatert med omgivelsene.</h3>
                    </section>
                    <section>
                        <h3>En måte for data å reagere på endringer og oppdatere for å reflektere disse endringene.</h3>
                    </section>
                    <section>
                        <h3>Et eksempel på reaktiv data kan være et regneark og summen av to tall.</h3>
                    </section>
                    <section>

                        <div class="dataflow-example">
                            <input type="number" id="a" value="3" class="node-a"/>
                            <input type="number" id="b" value="2" class="node-b"/>
                            <input type="text" id="sum" value="0" disabled="" class="node-result"/>
                        </div>

                        <script>
                            (function () {
                                var _add = function (a, b) { return a + b; },
                                    _value = function (e) { return e.currentTarget.value; },
                                    getInputAsProperty = function (id) {
                                        var $el = $(id);
                                        return $el.asEventStream("change")
                                                  .map(_value)
                                                  .toProperty($el.val())
                                                  .map(Number);
                                    };

                                var $a = getInputAsProperty("#a"),
                                    $b = getInputAsProperty("#b");

                                $a.combine($b, _add).assign($("#sum"), "val");
                            })();
                        </script>
                    </section>
                </section>

                <section>
                    <section><h2>Funksjonell Reaktiv Programmering</h2></section>
                    <section>
                        <h3>To generelle konsepter</h3>
                        <ol>
                            <li>Behaviours (Adferd)</li>
                            <li>Events (Hendelse)</li>
                        </ol>
                    </section>
                    <section>
                        <h3>Adferder</h3>
                        <p>En kontinuerlig verdi. Eksemeplvis klokken, høyde eller vektorgrafikk.</p>
                    </section>
                    <section>
                        <h3>Hendelser</h3>
                        <p>En diskret verdi. Eksempelvis muse-klikk eller en mengde.</p>
                    </section>
                    <section>
                        <h3>I FRP blir hendelser og adferder behandlet som sekvenser og kan bli håndtert på en funksjonell måte.</h3>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>FRP i frontend</h2>
                    </section>
                    <section>
                        <h3>Reaktivt</h3>
                        <p>Representasjon og oppdatering av elementer.</p>
                        <aside class="notes">Siden GUIer er naturlig tilstandsfulle trenger vi noe som kan representere den tilstanden og tillate oss å endre den. Reaktiv programmering gir oss datatyper for å representere elementene i GUIet vårt.

                        Den praktiske effekten av dette er at vi ikke trenger å manuelt endre tilstanden til elementer. Og vi får første-klasses datatyper til å representere elementer og forhold dem i mellom.</aside>
                    </section>
                    <section>
                        <h3>Funksjonelt</h3>
                        <p>Men med side-effekter</p>
                        <aside class="notes">Purely-functional tillater ikke side-effects. Men, siden vi benytter oss av reaktiv programmering så vil de reaktive data-typene håndtere side-effectene for oss slik at vi kan programmere i en funksjonell verden uten at side-effektene påvirker oss.

                        Dette gjør oss i stand til å benytte funksjonell programmering til å komponere forhold mellom GUI elementer og transformere data.</aside>
                    </section>
                    <section>
                        <h3>Deklarativt</h3>
                        <p>Spør heller hva enn hvordan</p>
                        <aside class="notes">Når vi kombinerer funksjonell og reaktiv programmering gir det oss muligheten til å gjøre koden deklarativ. Vi ikke trenger å gjøre noen manuelle side-effekter og kan derfor heller fokusere på hva vi ønsker å oppnå enn hvordan vi ønsker å oppnå det.

                        Dette gjør at vi bare trenger å assigne representasjonen av en adferd eller hendelse en gang. Hver gang vi lager en representasjon av enten en adferd eller hendelse eller en kombinasjon av flere så endrer vi ikke på den orginale representasjonen. Dette gjør oss i stand til å lage så mange representasjoner som vi har behov for.</aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>Abstraksjonsammenligning: Backbone.js</h2>
                    </section>
                    <section>
                        <h3>Models og Views</h3>
                        <aside class="notes">Kort sammendrag av Backbone's primære abstraksjoner for GUI; Models og Views. Models brukes for å representere tilstanden til data, mens Views brukes for å representere tilstanden til GUI. Forholdet mellom Model og View er løst koblet og krever en del manuell setup og boilerplate.</aside>
                    </section>
                    <section>
                        <h3>Representasjon av data</h3>
                        <p>Models vs Adferder</p>
                        <aside class="notes">I Backbone så representeres data som en modell. Den primære funksjonen til en modell her er å kunne abstrahere vekk intern tilstand og varsle om relevante endringer i intern tilstand. Den interne tilstanden er veldig fleksibel og Bacbone legger ingen føringer på det.

                        FRP representerer data som en adferd. For at FRP skal kunne representere data er man avengig av å ha en kilde som kan produsere data, feks ajax eller noe som representerer en konstant verdi. Adferder kan kombineres og på den måten kan du representere sammensatte data.

                        Siden en adferd alltid har en verdi kan man tilordne dem til et element og på den måten gjøre verdien synlig i grensesnittet. Og siden adferder er reaktive sørger det for at den synlige biten i grensesnittet alltid er oppdatert med verdien til adferden.

                        Ser man på APIet som eksponeres, så er det ikke så stor forskjell på de to abstraksjonene. Begge abstraksjonene kommuniserer ved hjelp av events, forskjellen ligger i hvordan events blir håndtert av mottaker. I FRP så vil den reaktive stilen sørge for at andre som avhenger av adferden oppdaterer seg selv, mens i Bacbone så må en håndtere det manuelt selv.</aside>
                    </section>
                    <section>
                        <h3>Representasjon av interaksjon</h3>
                        <p>View vs Hendelse</p>
                        <aside class="notes">Views i backbone er en innkapsling av funksjonalitet knyttet til en bit av grensesnittet. Koblingen mot GUIet er ganske løs og består hovedsaklig av event-lyttere og en template-funksjon som interpolerer data med markup. For å få avansert interaksjon kan man benytte en modell til å holde data eller ha en intern state i viewet.

                        Views kan kombineres ved nøsting for å innkapsle ytterligere og på den måten oppnå mer avansert funksjonalitet. Man har også mulighet for arv for å dele funksjonalitet, men arv har sine begrensninger og det kan føre til økt kompleksitet eller brudd på DRY.

                        I FRP så bruker man hendelser, diskrete hendelser i tid, til å representere de elementene som reagerer på interaksjon med grensesnittet. I FRP er det ikke hendelser som er direkte ansvarlig for å gjøre data synlig i grensesnittet, men hendelser kan fortsatt styre når eller hvordan oppdateringen skjer.

                        For å skape mer avansert interaksjon kan man i FRP komponere hendelser funksjonellt. At du hele tiden benytter deg av de reaktive datatypene gir deg en felles interface og at du ikke har noen intern tilstand i en hendelse gjør at du har mye friere tøyler når det kommer til gjenbruk av funksjonalitet.</aside>
                    </section>
                    <section>
                        <h3>Abstraksjonsammenligning</h3>
                        <p>Oppsummering</p>
                        <aside class="notes">FRP tilbyr minimale byggestener for å komponere mer avanserte strukturer for både interaksjon og data. Mens model og view legger seg på et høyre abstraksjonsnivå  og legger opp til mer manuell sammenkobling av GUI og kode. FRP er deklarativt, mens Model/View er imperativt.

                        Komposisjonsmulighetene er kanskje den største forskjellen mellom FRP og Model/View-abstraksjonen. I FRP gjør man funksjonell komponering. Fordi man har en universell interface i de reaktive datatypene kan man gjenbruke funksjoner på tvers av alt. I Model/View, som stort sett er objekt orientert, komponerer man ved å nøste (has-a) eller arve (is-a). Dette begrenser potensialet for gjenbruk til ting du kan utrykke med de forholdene.

                        That being said, det er egentlig ingenting i veien for å kombinere semantikken i Model/View abstraksjonen men en implementasjon som benytter seg av FRP. I bunn og grunn er View og Model bare innkapslinger av et sett med funksjonalitet som tilsammen utgjør en komponent.</aside>
                    </section>

                    <section>
                        <section>
                            <h2>Abstraksjonsammenligning: Knockout.js</h2>
                        </section>
                        <section>
                            <h3>Representasjon av data</h3>
                            <p>ViewModel vs Adferd</p>
                            <aside class="notes"></aside>
                        </section>
                        <section>
                            <h3>Representasjon av interaksjon</h3>
                            <p>View vs Hendelse</p>
                            <aside class="notes"></aside>
                        </section>
                        <section>
                            <h3>Abstraksjonsammenligning</h3>
                            <p>Oppsummering</p>
                            <aside class="notes"></aside>
                        </section>
                    </section>

                    <section>
                        <h3>Angular.js?</h3>
                        <aside class="notes">Har valgt å ikke sammenligne med Angular.js, mest fordi de bitene av angular som overlapper mest med FRP stort sett er de samme som i Knockout; deklarative bindinger mot data og deklarative event-lyttere.</aside>
                    </section>
                </section>


                <section class="vote-example">
                    <section><h2>Eksempel med WebSockets og flere klienter.</h2></section>
                    <section><h3>Vi skal lage et enkelt system for spørreundersøkelser basert på WebSockets.</h3></section>
                    <section>
                        <pre><code data-trim>var socketStream =
    Bacon.fromEventTarget(socket, "vote")</code></pre>
                    </section>
                    <section>
                        <pre><code data-trim>var totalVoteProperty = function (id) {</code></pre>
                        <pre class="fragment"><code>    return socketStream</code></pre>
                        <pre class="fragment"><code>        .filter(_isId(id))</code></pre>
                        <pre class="fragment"><code>        .map(1)</code></pre>
                        <pre class="fragment"><code>        .scan(0, _add);</code></pre>
                        <pre><code>};</code></pre>
                    </section>

                    <section>

                        <pre><code data-trim>var percentage = function (stream, total) {</code></pre>
                        <pre><code class="fragment">    return stream</code></pre>
                        <pre><code class="fragment">            .combine(total, _toPercentage);</code></pre>
                        <pre><code data-trim>};</code></pre>
                    </section>

                    <section>
                        <pre><code data-trim>var sum = socketStream.map(1).scan(0, _add);</code></pre>
                    </section>

                    <section>
                        <pre><code data-trim>[1, 2, 3].forEach(function (id) {</code></pre>
                        <pre><code class="fragment" data-fragment-index="1">  return percentage(</code></pre>
                        <pre><code class="fragment" data-fragment-index="1">    totalVoteProperty("alt" + id), sum)</code></pre>
                        <pre><code class="fragment">        .assign($("#alt" + id), "val");</code></pre>
                        <pre><code data-trim>});</code></pre>
                    </section>

                    <section><h2>Demo</h2></section>

                    <section>
                        <h3>Her er det et spørsmål som er stilt, og det kan potensielt være langt?</h3>
                        <progress max="100" id="alt1" value="0" data-skill="Ett alternativ her" class="progress-red"></progress>
                        <progress max="100" id="alt2" value="0" data-skill="Et annet alternativ som er lengre" class="progress-yellow"></progress>
                        <progress max="100" id="alt3" value="0" data-skill="Noe slags opplegg her og..." class="progress-green"></progress>

                        <h4>Avgi din stemme på: <a href="#">bit.ly/NOEHER</a></h4>

                        <script>
                        (function () {
                            var socket = new io.connect(),
                                socketStream = Bacon.fromEventTarget(socket, "vote"),
                                _isId = function (id) {
                                    return function (data) {
                                        return data === id;
                                    };
                                },
                                _add = function (a, b) {
                                    return a + b;
                                },
                                _toPercentage = function (value, sum) {
                                    return sum === 0 ? 0 : (value / sum) * 100;
                                };

                            var totalVoteProperty = function (id) {
                                return socketStream.filter(_isId(id)).map(1).scan(0, _add);
                            };

                            var percentage = function (stream, total) {
                                return stream.combine(total, _toPercentage);
                            };

                            var sum = socketStream.map(1).scan(0, _add);

                            [1, 2, 3].forEach(function (id) {
                                percentage(totalVoteProperty("alt" + id), sum)
                                    .assign($("#alt" + id), "val");
                            });
                        }());
                        </script>
                    </section>
                </section>

                <section>
                    <section><h2>Takk for oss!</h2></section>
                    <section><h1>Spørsmål?</h1></section>

                </section>
            </div>

        </div>

        <script src="./lib/js/head.min.js"></script>
        <script src="./js/reveal.min.js"></script>

        <script>

            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; }},
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                    ]
            });

        </script>

    </body>
</html>
