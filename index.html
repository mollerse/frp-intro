<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Intro til FRP</title>

        <link rel="stylesheet" href="./css/reveal.min.css">
        <link rel="stylesheet" href="./css/theme/night.css">
        <link rel="stylesheet" href="./css/main.css">
        <link rel="stylesheet" href="./css/vote-example.css">
        <link rel="stylesheet" href="./css/monokai-sublime.css">


        <script type="text/javascript" src="js/jquery.js"></script>
        <script type="text/javascript" src="js/bacon.js"></script>
        <script type="text/javascript" src="/socket.io/socket.io.js"></script>
    </head>

    <body>

        <div class="reveal">

            <div class="slides">

                <section>
                    <h2>Introduksjon til Functional Reactive Programming (FRP)</h2>
                    <p>BEKK Fagdag</p>
                    <p>Stian Veum Møllersen / <a href="http://twitter.com/mollerse">@mollerse</a></p>
                    <p>Mikael Brevik / <a href="http://twitter.com/mikaelbrevik">@mikaelbrevik</a></p>
                    <p><a href="http://open.bekk.no">open.bekk.no</a></p>
                </section>

                <section>
                    <h2>Agenda</h2>
                    <ol>
                        <li class="fragment">Teoretisk introduksjon</li>
                        <li class="fragment">FRP i front-end</li>
                        <li class="fragment">Bacon.js</li>
                        <li class="fragment">Praktiske eksempler og demo</li>
                    </ol>
                </section>

                <section>
                    <h3>Hva er Functional Reactive Programming?</h3>
                    <p>Kombinasjonen mellom to paradigmer:</p>
                    <ol>
                        <li>Funksjonell programmering</li>
                        <li>Reaktiv programmering</li>
                    </ol>
                </section>

                <section>
                    <section><h2>Funksjonell programmering</h2></section>
                    <section>
                        <h3>En deklarativ programmeringsparadigme med funksjoner i fokus.</h3>
                        <h4>Unngår tilstander og mutable objekter.</h4>
                        <aside class="notes">
                            <p>Handler om hvilken input et system for, i motsetning til hvilken tilstand systemet har. Gitt at input alltid er lik, vil også output bli like - altså rene (pure) funksjoner.</p>
                            <p>Ettersom funksjonell programmering skal hindre bieffekter, opererer det gjerne med immutable objekter (objekter/verdier som ikke kan endres).</p>
                        </aside>
                    </section>
                    <section>
                        <h4>Deklarativ programmering forklarer hva som skjer.</h4>
                        <h4>Imperativ programmering forklarer hvordan det skal skje!</h4>
                        <aside class="notes">
                            <p>Deklarativ programmering opererer som regel med utrykk (expressions) som kan evalueres til verdier, fremfor erklæringer (statements) som forklarer fremgangsmåte.</p>
                            <p>Markup som HTML kan sees som deklarativt, ettersom vi definerer hva vi vil ha, ikke hvordan vi skal ha det.</p>
                            <p>Eksempel: I imperativ programmering ville vi ha iterert over verdier med en for-løkke og endret verdiene i løkke-kroppen. I deklarativ programmering vil vi typisk sende med en første-klasses høyere ordens funksjon (funksjoner som kan sendes som argument til andre funksjoner - høyere ordens funksjoner: funksjoner som kan returnere andre funksjoner) som kjøres rekursivt (head | rest...) over en sekvens og returnerer en ny sekvens med det transformerte innholdet.</p>
                        </aside>
                    </section>
                    <section>
                        <h3>Unngår uønskede bieffekter</h3>
                        <aside class="notes">
                            <p>Der et funksjonskall påvirker systemet på annet måte enn kun det funksjonskallet returnerer.</p>
                            <p>F.eks endringer på statiske/globale variabler i en funksjon. Dette påvirker systemet/tilstanden til systemet.</p>
                        </aside>
                    </section>
                    <section>
                        <h3>Vanlig med bruk av blant annet <code>map</code>, <code>reduce</code> og <code>filter</code>.</h3>
                        <h4 class="fragment">Eksempler på språk kan være Lisp, Haskell, Scala, men også JavaScript</h4>
                        <aside class="notes">
                            <p>Map tar inn et en sekvens og en høyere ordens funksjon, returnerer en ny sekvens der alle elementer i sekvensen er blitt kjørt via innsendt funksjon.</p>
                            <p>Reduce kjører rekursivt over en sekvens og evaluerer en høyere ordens funksjon som tar inn resultatet fra forrige kjøring og gjeldene element i sekvensen. Ved første iterasjon vil verdien fra første kjøring være satt til en initiell verdi.</p>
                            <p>Filter vil og kjøres rekursivt og ta inn en sekvens og et predikat (predikat kan forklares som noe som returnerer true/false basert på argumenter) og returnerer en ny sekvens kun med de elementene som oppfyller predikatet.</p>

                            <p>Ikke alle språkene er 100% funksjonelle, da de tillater mutable objekter og bieffekter, men kan brukes funksjonelt og har støtte for første-klasses høyere-ordens funksjoner.</p>
                        </aside>
                    </section>
                </section>
                <section>
                    <section><h2>Reaktiv programmering</h2></section>
                    <section>
                        <h3>Kan beskrives som en metode for å holde systemet kontinuerlig oppdatert med omgivelsene.</h3>
                        <aside class="notes">
                            <p>Kalles ofte dataflyt (dataflow) programmering.</p>
                        </aside>
                    </section>
                    <section>
                        <h3>En måte for data å reagere på endringer og oppdatere for å reflektere disse endringene.</h3>
                        <aside class="notes">
                            <p>Gitt at du har variabeler med avhengigheter (f.eks c = a * b), dersom A endres, vil endringene propagere i dataflyt grafen og oppdatere de verdiene som er avhengig av variabel A (i dette tilfellet verdien C).</p>
                            <p>Det kan være flere nivå av avhengigheter og komplekse dataflyt grafer.</p>
                        </aside>
                    </section>
                    <section>
                        <h3>Et eksempel på reaktiv data kan være et regneark og summen av to tall.</h3>
                        <aside class="notes">
                            <p>I Excel, om en har 5 verdier i kolonne A, og en celle som har SUM(A1:A5), vil summen oppdateres dersom en av cellene i kolonne A blir endret.</p>
                            <p>Dette er enkle eksempler på reaktivitet, men det kan også brukes i større komplekse sammenhenger, særlig med brukerinteraksjoner og animasjoner.</p>
                        </aside>
                    </section>
                    <section>

                        <div class="dataflow-example">
                            <input type="number" id="a" value="3" class="node-a"/>
                            <input type="number" id="b" value="2" class="node-b"/>
                            <input type="text" id="sum" value="0" disabled="" class="node-result"/>
                        </div>

                        <script>
                            (function () {
                                var _add = function (a, b) { return a + b; },
                                    _value = function (e) { return e.currentTarget.value; },
                                    getInputAsProperty = function (id) {
                                        var $el = $(id);
                                        return $el.asEventStream("change")
                                                  .map(_value)
                                                  .toProperty($el.val())
                                                  .map(Number);
                                    };

                                var $a = getInputAsProperty("#a"),
                                    $b = getInputAsProperty("#b");

                                $a.combine($b, _add).assign($("#sum"), "val");
                            })();
                        </script>
                    </section>
                </section>

                <section>
                    <section><h2>Funksjonell Reaktiv Programmering</h2></section>
                    <section>
                        <h3>To generelle konsepter</h3>
                        <ol>
                            <li>Behaviours (Adferd)</li>
                            <li>Events (Hendelse)</li>
                        </ol>
                        <aside class="notes">
                            <p>Adferder og hendelser er to forskjellige kilder av informasjon som vi skal se på litt nærmere.</p>
                        </aside>
                    </section>
                    <section>
                        <h3>Adferder</h3>
                        <p>En kontinuerlig verdi. Eksemeplvis klokken, høyde eller vektorgrafikk.</p>

                        <aside class="notes">
                            <p>En adferd vil alltid ha en verdi. Det er noe som er kontinuerlig, og som er målbart.</p>
                            <p>Selv om en adferd har en kontinuerlig verdi kan den måles/observeres til å ha en spesifikk verdi.</p>
                            <p>F.eks selv om høyden min aldri ikke eksisterer (altså er kontinuerlig), kan jeg måle den på nåværende tidspunkt.</p>
                        </aside>
                    </section>
                    <section>
                        <h3>Hendelser</h3>
                        <p>En diskret verdi. Eksempelvis muse-klikk eller en mengde.</p>

                        <aside class="notes">
                            <p>Diskrete verdier eksisterer kun når de inntreffer, og i mellomtiden er det ikke eksisterende.</p>
                            <p>F.eks om en gjør et museklikk vil den ha en verdi (binært 1, i dette tilfellet) i det musen blir klikket, men i det den er ferdig-trykket, vil verdien slutte å eksistere.</p>
                        </aside>
                    </section>
                    <section>
                        <h4>I FRP blir adferder og hendelser behandlet som sekvenser og kan bli håndtert på en funksjonell måte.</h4>

                        <aside class="notes">
                            <p>F.eks med bruken av "map", "reduce" eller "filter".</p>
                            <p>Om man bruker "map" på en hendelse, vil et funksjonskall bli kalt på verdien hver gang hendelsen inntreffer. Utfallet etter map vil være en ny hendelse der verdien er transformert.</p>
                            <p>Om en f.eks bruker "filter", vil en få ut en hendelsessekvens som kun inneholder hendelser som oppfyller predikatet som er sendt inn i filter-kallet.</p>
                            <p>Med "reduce" vil det som bli returnert være en adferd, ettersom den da alltid vil ha verdier.</p>
                        </aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>FRP i frontend</h2>
                    </section>
                    <section>
                        <h3>Reaktive datatyper</h3>
                        <p>Representasjon av tilstand</p>
                        <aside class="notes">
                            Siden GUIer er naturlig tilstandsfulle trenger vi noe som kan representere den tilstanden og tillate oss å endre den. Reaktiv programmering gir oss datatyper for å representere tilstanden elementene i GUIet vårt. Til forskjell fra det velkjente MVC-konseptet så dreier representasjon i FRP seg mer om å dele ting opp i enkeltelementer kontra sammensatte kompoenenter.

                            Den asynkrone naturen til et brukergrensesnitt er også spesielt utfordrende å forholde seg til hvis man samtidig skal sjonglere tilstand. Fordelen med reaktive datatyper i GUI design er at vi får automatisk propagering av tilstandsendringer og ikke behøver å håndtere dette selv.
                        </aside>
                    </section>
                    <section>
                        <h3>Sammensatt data</h3>
                        <p>Mange bekker små...</p>
                        <aside class="notes">
                            For å lage sammensatt data i FRP kan vi kombinere de reaktive datatypene slik at de danner mer komplekse strukturer. Den store fordelen her er at du til en hver tid er garantert av den reaktive egenskapen at endringer i tilstand propagerer gjennom hele den sammensatte strukturen.

                            Her skiller FRP seg mest fra objekt-orienterte implementasjoner. Den primære funksjonen til et objekt i objekt-orientert kode er å kunne abstrahere vekk intern tilstand og varsle eksternt om relevante endringer i intern tilstand. Det blir da opp til hver enkelt komponent som er interessert i endringene i modellen å gjøre noe med det.
                        </aside>
                    </section>
                    <section>
                        <h3>Forskjell fra MVC-Model</h3>
                        <p>Implementasjon og konsept</p>
                        <aside class="notes">
                            Den vanligste måten å realisere model-konseptet fra MVC med objekt orientering. I vanlig objekt-orientert kode er det vanlig å innkapsle tilstand i objekter og så tilby metoder som eksponerer eller endrer den interne tilstanden.

                            Sammenligner vi det med de reaktive datatypene fra FRP, så blir de mer som enkelte attributter på et model-objekt. Og komposisjoner av disse datatypene vil gi den samme effekten av sammensatt data som i objekt-orientert model.

                            Siden MVC-Model egentlig ikke legger noen føringer på implementasjonsdetaljer så er det ingenting i veien for å realisere konseptet som sammensatte reaktive datatyper. Da blir MVC-Modelen også en reaktiv datatype. Og man oppnår den samme avgrensningen av funksjonalitet, dog uten innkapslingen.
                        </aside>
                    </section>
                    <section>
                        <h3>GUI uten bi-effekter?</h3>
                        <p>Selvfølgelig, reaktive datatyper fikser biffen</p>
                        <aside class="notes">
                            Purely-functional tillater ikke side-effects. Men, siden vi benytter oss av reaktiv programmering så vil de reaktive data-typene håndtere side-effectene for oss slik at vi kan forholde oss til en funksjonell verden uten at side-effektene påvirker oss.

                            Dette gjør oss i stand til å benytte funksjonell programmering til å komponere de reaktive datatypene og transformere data.
                        </aside>
                    </section>
                    <section>
                        <h3>Funksjonell komposisjon</h3>
                        <p>Med generelle kombinatorer</p>
                        <aside class="notes">
                            For å skape mer avansert oppførsel i grensesnittet kan man i FRP komponere de reaktive datatype funksjonelt. Fordelen med at det er så få bestandeler i FRP er at du får et felles grensesnitt mellom komponentene du benytter deg av. Du kan dermed bruke generelle kombinatorer som map, filter og reduce. Dette gjør det blir enklere å sette sammen enkle komponenter som sammen blir til mer en kompleks komponent.
                        </aside>
                    </section>
                    <section>
                        <h3>Gjenbruk av kode</h3>
                        <p>Keeping it DRY</p>
                        <aside class="notes">
                            At du hele tiden benytter deg av de reaktive datatypene som ikke har noen intern tilstand i en hendelse gjør at du har mye friere tøyler når det kommer til gjenbruk av funksjonalitet. Du slipper å strukturere gjenbruk som et resultat av forhold mellom objekter, typiske is-a eller has-a forhold.
                        </aside>
                    </section>
                    <section>
                        <h3>Synlighet i grensesnittet</h3>
                        <p>Binde adferder til GUI elementer</p>
                        <aside class="notes">
                            Den vanligste måten å synliggjøre data i grensesnitt med FRP er å tilordne en GUI komponent en avhengighet til en adferd. Dette forholdet er reaktivt, på lik linje med resten av komponentene i FRP, og sørger dermed for at GUI komponenten alltid reflekterer tilstanden til det elementet det har en avhengighet til.

                            Det beste med denne måten å gjøre data synlig i grensesnittet er at det hele er deklarativt. Til forskjell fra den tradisjonelle hendelses-drevne måten å gjøre ting på, hvor alt er manuelt. Så setter man heller opp rettede avhengigheter mellom elementer og komponenter og konsturerer et slags nettverk mellom data-kilder og data-konsumenter.
                        </aside>
                    </section>
                    <section>
                        <h3>Knockout.js</h3>
                        <p>FRP eller ikke?</p>
                        <aside class="notes">
                            Mange kjenner sikkert til Knockout.js og synes det deklarative bindingskonseptet virker ganske likt det som blir skissert i FRP.

                            I Knockout.js har de konseptet om Observables. Observables varsler sine avhengigheter om endringer i tilstand, på samme måte som de reaktive datatypene i FRP. I Knockout dreier det hele seg om deklarative bindinger i templates som automatisk er bundet mot observables i bakenforliggende ViewModels og er sånt sett tro mot konseptet FRP.

                            En av de stedene Knockout.js og FRP skiller litt lag er i den funksjonelle biten. FRP legger til rette for funksjonell komposisjon for å oppnå avansert oppførsel. Knockout har en mye mer begrenset form for komposisjon som baserer seg på semantikk fra objekt orientering.

                            Reaktivt? Ja. Funksjonellt? Nei.
                        </aside>
                    </section>
                    <section>
                    <h2>FRP i frontend</h2>
                    <p>Oppsummering</p>
                    <ul>
                        <li class="fragment">Reaktive datatyper</li>
                        <li class="fragment">Funksjonell komponering</li>
                        <li class="fragment">Representerer GUI-komponenter med reaktive datatyper</li>
                    </ul>
                    <aside class="notes">
                        Du har to reaktive datatyper; hendelser og adferder. Avansert funksjonalitet oppnåes ved å kombinere adferder og hendelser i større og mer komplekse strukturer med funksjonell komposisjon. Komponenter i GUIet representeres som en slik reaktiv datatype og får dermed dra nytte av de reaktive egenskapene med automatisk propagering av tilstandsendringer.
                    </aside>
                </section>
            </section>

                <section>
                    <section>
                        <h2>Praktisk FRP</h2>
                        <p>Enter Bacon.js</p>
                    </section>
                    <section>
                        <h3>Introduksjon til Bacon.js sin implementasjon av FRP konseptene.</h3>
                    </section>
                </section>

                <section class="form-example">
                    <section>
                        <h2>Eksempel: Ufylling av skjema</h2>
                    </section>
                    <section>
                        <h3>Funksjonalitet i eksempelet</h3>
                        <ul>
                            <li class="fragment">Fylle skjema med serverdata</li>
                            <li class="fragment">Validere enkelt-inputs</li>
                            <li class="fragment">Validere hele skjemaet</li>
                            <li class="fragment">Sende tilbake til server</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Fylle skjemaet med serverdata</h3>
                    </section>
                    <section>
                                <pre><code>var record =
    Bacon.fromPromise($.get('/record'));</code></pre>
                    </section>
                    <section>
                        <div class="code">
                            <pre class="fragment"><code>record.map('.name')
        .assign($("#name"), 'val');</code></pre>
                            <pre class="fragment"><code>record.map('.rank')
        .assign($("#rank"), 'val');</code></pre>
                            <pre class="fragment"><code>record.map('.serialnumber')
        .assign($("#serialnumber"), 'val');</code></pre>
                        </div>
                    </section>
                    <section>
                        <pre><code>record.onValue(function() {
    $("input").trigger('keyup');
});</code></pre>
                        <aside class="notes">
                            Fordi DOMen ikke er 100% reaktiv, som bacon.js, må vi tvinge DOMen til å propagere tilstandsendringen videre.
                        </aside>
                    </section>
                    <section>
                        <h3>Validere enkelt-inputs</h3>
                    </section>
                    <section>
                        <div class="code">
                        <pre class="fragment" data-fragment-index="1"><code>var propertyFromInput = function(field) {</code></pre>
                        <pre class="fragment" data-fragment-index="2"><code>    return Bacon.fromEventTarget(field, 'keyup')</code></pre>
                        <pre class="fragment" data-fragment-index="3"><code>        .map(value)</code></pre>
                        <pre class="fragment" data-fragment-index="4"><code>        .toProperty(value());</code></pre>
                        <pre class="fragment" data-fragment-index="1"><code>}</code></pre>
                        </div>
                    </section>
                    <section>
                        <div class="code">
                            <pre><code>var name = propertyFromInput($("#name"));</code></pre>
                            <pre><code>var rank = propertyFromInput($("#rank"));</code></pre>
                            <pre><code>var serialnumber = propertyFromInput($("#serialnumber"));</code></pre>
                        </div>
                    </section>
                    <section>
                        <pre><code>var newRecord = Bacon.combineTemplate({
    "name": name,
    "rank": rank,
    "serialnumber": serialnumber
});</code></pre>
                    </section>
                    <section>
                        <div class="code">
                            <pre class="fragment"><code>var validName = name.map(Boolean);</code></pre>
                            <pre class="fragment"><code>validName.not().assign($("#name + span"), 'toggle');</code></pre>
                        </div>
                    </section>
                    <section>
                        <div class="code">
                            <pre class="fragment"><code>var validRank = rank.map(function(r) {
    var validRanks =  ['Captain', 'Corporal',
                        'General', 'Private'];
    return validRanks.indexOf(r) != -1;
});
                                </code></pre>
                            <pre class="fragment"><code>validRank.not().assign($("#rank + span"), 'toggle');</code></pre>
                        </div>
                    </section>
                    <section>
                        <div class="code">
                            <pre class="fragment"><code>var validSerialnumber = serialnumber.map(function(s) {
    return /^\d{5}-\w{3}$/.test(s);
});
                                </code></pre>
                            <pre class="fragment"><code>validSerialnumber.not()
    .assign($("#serialnumber + span"), 'toggle');</code></pre>
                        </div>
                    </section>
                    <section>
                        <h3>Validering av hele skjemaet</h3>
                        <pre><code>validName.and(validRank).and(validSerialnumber).not()
    .assign($("button"), 'attr', 'disabled');</code></pre>
                    </section>
                    <section>
                        <h3>Sende data tilbake til server</h3>
                    </section>
                    <section>
                        <pre class="fragment"><code>var save =
    Bacon.fromEventTarget($("button"), 'click')
        .doAction('.preventDefault');</code></pre>
                    </section>
                    <section>
                        <div class="code">
                            <pre class="fragment" data-fragment-index="1"><code>var response = newRecord.sampledBy(save)</code></pre>
                            <pre class="fragment" data-fragment-index="2"><code>    .flatMapLatest(function(record) {</code></pre>
                            <pre class="fragment" data-fragment-index="3"><code>        return Bacon.fromPromise($.ajax({
            "url": "/record",
            "type": "POST",
            "data": JSON.stringify(record)
        }));</code></pre>
                            <pre class="fragment" data-fragment-index="2"><code>});</code></pre>
                        </div>
                    </section>

                    <section>
                        <h2>Demo</h2>
                        <div>
                            <form>
                                <div><label for="name">Name</label></div>
                                <input id="name" type="text"><span style="color: red">!</span>
                                <div><label for="rank">Rank</label></div>
                                <input id="rank" type="text"><span style="color: red">!</span>
                                <div><label for="serialnumber">Serial Number</label></div>
                                <input id="serialnumber" type="text"><span style="color: red">!</span>
                                <div>
                                    <button style="font-size: larger; margin-top: 1em">Add</button>
                                </div>
                            </form>
                        </div>
                        <script>
                            (function() {
                                var propertyFromInput = function(field) {
                                    var value = function() {
                                        return field.val();
                                    };
                                    return Bacon.fromEventTarget(field, 'keyup')
                                        .map(value)
                                        .toProperty(value());
                                };

                                var record = Bacon.fromPromise($.get('/record'));
                                record.map('.name').assign($("#name"), 'val');
                                record.map('.rank').assign($("#rank"), 'val');
                                record.map('.serialnumber').assign($("#serialnumber"), 'val');
                                record.onValue(function() {
                                    $("input").trigger('keyup');
                                });

                                var name = propertyFromInput($("#name"));
                                var rank = propertyFromInput($("#rank"));
                                var serialnumber = propertyFromInput($("#serialnumber"));

                                var newRecord = Bacon.combineTemplate({
                                    "name": name,
                                    "rank": rank,
                                    "serialnumber": serialnumber
                                });

                                var validName = name.map(Boolean);
                                validName.not().assign($("#name + span"), 'toggle');

                                var validRank = rank.map(function(r) {
                                    var validRanks =  ['Captain', 'Corporal', 'General', 'Private'];
                                    return validRanks.indexOf(r) != -1;
                                });
                                validRank.not().assign($("#rank + span"), 'toggle');

                                var validSerialnumber = serialnumber.map(function(s) {
                                    return /^\d{5}-\w{3}$/.test(s);
                                });
                                validSerialnumber.not().assign($("#serialnumber + span"), 'toggle');

                                validName.and(validRank).and(validSerialnumber).not()
                                    .assign($("button"), 'attr', 'disabled');

                                var save = Bacon.fromEventTarget($("button"), 'click').doAction('.preventDefault');

                                newRecord.sampledBy(save).flatMapLatest(function(record) {
                                    return Bacon.fromPromise($.ajax({
                                        "url": "/record",
                                        "type": "POST",
                                        "data": JSON.stringify(record)
                                    }));
                                });
                            }());
                        </script>
                    </section>

                </section>

                <section class="vote-example">
                    <section><h2>Eksempel med WebSockets og flere klienter.</h2></section>
                    <section><h3>Vi skal lage et enkelt system for spørreundersøkelser basert på WebSockets.</h3></section>
                    <section>
                        <h3>Vi må gjøre følgende</h3>
                        <ul>
                            <li class="fragment">Koble til og hente verdier ut fra WebSockets.</li>
                            <li class="fragment">Dersom vi får gyldig verdi fra WS, summere opp stemmene.</li>
                            <li class="fragment">Bruke totale stemmer og indeviduelle stemmer til å regne ut prosent.</li>
                            <li class="fragment">Representere resultatet i grensesnittet.</li>
                        </ul>
                    </section>
                    <section>
                        <pre><code data-trim>var socketStream =
    Bacon.fromEventTarget(socket, "vote")</code></pre>
                    </section>
                    <section>
                        <pre><code data-trim>var totalVoteProperty = function (id) {</code></pre>
                        <pre class="fragment"><code>    return socketStream</code></pre>
                        <pre class="fragment"><code>        .filter(_isId(id))</code></pre>
                        <pre class="fragment"><code>        .map(1)</code></pre>
                        <pre class="fragment"><code>        .scan(0, _add);</code></pre>
                        <pre><code>};</code></pre>
                        <aside class="notes">
                            <p>Vi skal finne totale antall stemmer et alternativ får.</p>
                            <p>Med å kjøre filter med predikatet <code>_isId</code>, får vi ut en hendelse som kun gjelder for alternativet med gitt ID.</p>
                            <p>Vi gjør om hendelsen til å kun ha verdier som er 1. Det vil si at hver gang hendelsen inntreffer, vil vi få verdien 1.</p>
                            <p>Scan som er nesten som reduce, bare at den gir melding hver gang den oppdateres. Reduce ville kun ha gitt en verdi når det ikke kommer flere verdier (WebSocketen hadde avsluttet). Når vi bruker scan her, og gir en initiell verdi på 0 og _add som transformator, vil resultatet være den totale summen.</p>
                            <p>Vi sitter igjen med en adferd som inneholder summen av stemmer for et alternativ med en gitt ID.</p>
                        </aside>
                    </section>

                    <section>
                        <pre><code data-trim>var percentage
    = function (numVotes, total) {</code></pre>
                        <pre><code class="fragment">    return numVotes</code></pre>
                        <pre><code class="fragment">            .combine(total, _toPercentage);</code></pre>
                        <pre><code data-trim>};</code></pre>

                        <aside class="notes">
                            <p>Ettersom vi skal vise prosentvis fordeling av alle alternativene, må ha en måte å regne det ut på.</p>
                            <p>Vi starter med antallet stemmer til et alternativ.</p>
                            <p><code>Combine</code> vil kombinere de to siste verdiene på begge kildene ved hjelp av en første ordens funksjon.</p>
                            <p>Om vi kombinerer antall stemmer på et alternativ med totale mengden stemmer og kjører prosentregning på den, har vi prosenten på antall stemmer til et gitt alternativ.</p>
                            <p>Det vi sitter igjen med etter dette er en adferd med prosenten til et alterantiv.</p>
                        </aside>
                    </section>

                    <section>
                        <pre><code data-trim>var sum = socketStream.map(1).scan(0, _add);</code></pre>
                        <aside class="notes">
                            <p>For å finne den totale mengden stemmer, kan vi gjøre det på samme måten som vi har gjort på individuelle alternativer, bare uten filtreringen.</p>
                        </aside>
                    </section>

                    <section>
                        <pre><code data-trim>["alt1", "alt2", "alt3"].forEach(
    function (id) {</code></pre>
                        <pre><code class="fragment" data-fragment-index="1">  return percentage(</code></pre>
                        <pre><code class="fragment" data-fragment-index="1">    totalVoteProperty(id), sum)</code></pre>
                        <pre><code class="fragment">        .assign($("#" + id), "val");</code></pre>
                        <pre><code data-trim>});</code></pre>

                        <aside class="notes">
                            <p>For å samle det hele, begynner vi med å iterere vi over ID-ene til de tre alternativene.</p>
                            <p>Vi ønsker å finne prosenten av den totale stemme-antallet for alternativ "ID" ut i fra den totale summen.</p>
                            <p>Vi vil sette denne prosenten til på DOM-elementet gitt av ID.</p>
                            <p>Det er det som trengs. Og vi har nå et fiks ferdig sanntids polling-system!</p>
                        </aside>
                    </section>

                    <section><h2>Demo</h2></section>

                    <section>
                        <h3>Hva er din politiske hjertesak?</h3>
                        <progress max="100" id="alt1" value="0" data-skill="Æ vil ha belli sprit!" class="progress-red"></progress>
                        <progress max="100" id="alt2" value="0" data-skill="Bygg et sperret asylmottak i utlandet." class="progress-yellow"></progress>
                        <progress max="100" id="alt3" value="0" data-skill="Grav etter mer penger i Lofoten!" class="progress-green"></progress>

                        <h4>Avgi din stemme på: <a href="http://frp.herokuapp.com">http://frp.herokuapp.com</a></h4>

                        <script>
                        (function () {
                            var socket = new io.connect("ws://frp.herokuapp.com:80/"),
                                socketStream = Bacon.fromEventTarget(socket, "vote"),
                                _isId = function (id) {
                                    return function (data) {
                                        return data === id;
                                    };
                                },
                                _add = function (a, b) {
                                    return a + b;
                                },
                                _toPercentage = function (value, sum) {
                                    return sum === 0 ? 0 : (value / sum) * 100;
                                };

                            var totalVoteProperty = function (id) {
                                return socketStream.filter(_isId(id)).map(1).scan(0, _add);
                            };

                            var percentage = function (stream, total) {
                                return stream.combine(total, _toPercentage);
                            };

                            var sum = socketStream.map(1).scan(0, _add);

                            ["alt1", "alt2", "alt3"].forEach(function (id) {
                                percentage(totalVoteProperty(id), sum)
                                    .assign($("#" + id), "val");
                            });
                        }());
                        </script>
                    </section>
                </section>

                <section>
                    <section><h2>Takk for oss!</h2></section>
                    <section><h1>Spørsmål?</h1></section>

                </section>
            </div>

        </div>

        <script src="./lib/js/head.min.js"></script>
        <script src="./js/reveal.min.js"></script>

        <script>

            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; }},
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });

        </script>

    </body>
</html>
