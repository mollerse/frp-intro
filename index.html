<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Intro til FRP</title>

        <link rel="stylesheet" href="./css/reveal.min.css">
        <link rel="stylesheet" href="./css/theme/night.css">
        <link rel="stylesheet" href="./css/main.css">
        <link rel="stylesheet" href="./css/vote-example.css">
        <link rel="stylesheet" href="./css/monokai-sublime.css">


        <script type="text/javascript" src="js/jquery.js"></script>
        <script type="text/javascript" src="js/bacon.js"></script>
        <script type="text/javascript" src="/socket.io/socket.io.js"></script>
    </head>

    <body>

        <div class="reveal">

            <div class="slides">

                <section>
                    <h2>Introduksjon til Functional Reactive Programming (FRP)</h2>
                    <p>BEKK Fagdag</p>
                    <p>Stian Veum Møllersen / <a href="http://twitter.com/mollerse">@mollerse</a></p>
                    <p>Mikael Brevik / <a href="http://twitter.com/mikaelbrevik">@mikaelbrevik</a></p>
                    <p><a href="http://open.bekk.no">open.bekk.no</a></p>
                </section>

                <section>
                    <h2>Agenda</h2>
                    <ol>
                        <li class="fragment">Teoretisk introduksjon</li>
                        <li class="fragment">FRP i front-end</li>
                        <li class="fragment">Bacon.js</li>
                        <li class="fragment">Praktiske eksempler og demo</li>
                    </ol>
                </section>

                <section>
                    <h3>Hva er Functional Reactive Programming?</h3>
                    <p>Kombinasjonen mellom to paradigmer:</p>
                    <ol>
                        <li>Funksjonell programmering</li>
                        <li>Reaktiv programmering</li>
                    </ol>
                </section>

                <section>
                    <section><h2>Funksjonell programmering</h2></section>
                    <section>
                        <h3>En deklarativ programmeringsparadigme med funksjoner i fokus.</h3>
                        <h4>Unngår tilstander og mutable objekter.</h4>
                        <aside class="notes">
                            <p>Handler om hvilken input et system for, i motsetning til hvilken tilstand systemet har. Gitt at input alltid er lik, vil også output bli like - altså rene (pure) funksjoner.</p>
                            <p>Ettersom funksjonell programmering skal hindre bieffekter, opererer det gjerne med immutable objekter (objekter/verdier som ikke kan endres).</p>
                        </aside>
                    </section>
                    <section>
                        <h4>Deklarativ programmering forklarer hva som skjer.</h4>
                        <h4>Imperativ programmering forklarer hvordan det skal skje!</h4>
                        <aside class="notes">
                            <p>Deklarativ programmering opererer som regel med utrykk (expressions) som kan evalueres til verdier, fremfor erklæringer (statements) som forklarer fremgangsmåte.</p>
                            <p>Markup som HTML kan sees som deklarativt, ettersom vi definerer hva vi vil ha, ikke hvordan vi skal ha det.</p>
                            <p>Eksempel: I imperativ programmering ville vi ha iterert over verdier med en for-løkke og endret verdiene i løkke-kroppen. I deklarativ programmering vil vi typisk sende med en første-klasses høyere ordens funksjon (funksjoner som kan sendes som argument til andre funksjoner - høyere ordens funksjoner: funksjoner som kan returnere andre funksjoner) som kjøres rekursivt (head | rest...) over en sekvens og returnerer en ny sekvens med det transformerte innholdet.</p>
                        </aside>
                    </section>
                    <section>
                        <h3>Unngår uønskede bieffekter</h3>
                        <aside class="notes">
                            <p>Der et funksjonskall påvirker systemet på annet måte enn kun det funksjonskallet returnerer.</p>
                            <p>F.eks endringer på statiske/globale variabler i en funksjon. Dette påvirker systemet/tilstanden til systemet.</p>
                        </aside>
                    </section>
                    <section>
                        <h3>Vanlig med bruk av blant annet <code>map</code>, <code>reduce</code> og <code>filter</code>.</h3>
                        <h4 class="fragment">Eksempler på språk kan være Lisp, Haskell, Scala, men også JavaScript</h4>
                        <aside class="notes">
                            <p>Map tar inn et en sekvens og en høyere ordens funksjon, returnerer en ny sekvens der alle elementer i sekvensen er blitt kjørt via innsendt funksjon.</p>
                            <p>Reduce kjører rekursivt over en sekvens og evaluerer en høyere ordens funksjon som tar inn resultatet fra forrige kjøring og gjeldene element i sekvensen. Ved første iterasjon vil verdien fra første kjøring være satt til en initiell verdi.</p>
                            <p>Filter vil og kjøres rekursivt og ta inn en sekvens og et predikat (predikat kan forklares som noe som returnerer true/false basert på argumenter) og returnerer en ny sekvens kun med de elementene som oppfyller predikatet.</p>

                            <p>Ikke alle språkene er 100% funksjonelle, da de tillater mutable objekter og bieffekter, men kan brukes funksjonelt og har støtte for første-klasses høyere-ordens funksjoner.</p>
                        </aside>
                    </section>
                </section>
                <section>
                    <section><h2>Reaktiv programmering</h2></section>
                    <section>
                        <h3>Kan beskrives som en metode for å holde systemet kontinuerlig oppdatert med omgivelsene.</h3>
                        <aside class="notes">
                            <p>Kalles ofte dataflyt (dataflow) programmering.</p>
                        </aside>
                    </section>
                    <section>
                        <h3>En måte for data å reagere på endringer og oppdatere for å reflektere disse endringene.</h3>
                        <aside class="notes">
                            <p>Gitt at du har variabeler med avhengigheter (f.eks c = a * b), dersom A endres, vil endringene propagere i dataflyt grafen og oppdatere de verdiene som er avhengig av variabel A (i dette tilfellet verdien C).</p>
                            <p>Det kan være flere nivå av avhengigheter og komplekse dataflyt grafer.</p>
                        </aside>
                    </section>
                    <section>
                        <h3>Et eksempel på reaktiv data kan være et regneark og summen av to tall.</h3>
                        <aside class="notes">
                            <p>I Excel, om en har 5 verdier i kolonne A, og en celle som har SUM(A1:A5), vil summen oppdateres dersom en av cellene i kolonne A blir endret.</p>
                            <p>Dette er enkle eksempler på reaktivitet, men det kan også brukes i større komplekse sammenhenger, særlig med brukerinteraksjoner og animasjoner.</p>
                        </aside>
                    </section>
                    <section>

                        <div class="dataflow-example">
                            <input type="number" id="a" value="3" class="node-a"/>
                            <input type="number" id="b" value="2" class="node-b"/>
                            <input type="text" id="sum" value="0" disabled="" class="node-result"/>
                        </div>

                        <script>
                            (function () {
                                var _add = function (a, b) { return a + b; },
                                    _value = function (e) { return e.currentTarget.value; },
                                    getInputAsProperty = function (id) {
                                        var $el = $(id);
                                        return $el.asEventStream("change")
                                                  .map(_value)
                                                  .toProperty($el.val())
                                                  .map(Number);
                                    };

                                var $a = getInputAsProperty("#a"),
                                    $b = getInputAsProperty("#b");

                                $a.combine($b, _add).assign($("#sum"), "val");
                            })();
                        </script>
                    </section>
                </section>

                <section>
                    <section><h2>Funksjonell Reaktiv Programmering</h2></section>
                    <section>
                        <h3>To generelle konsepter</h3>
                        <ol>
                            <li>Behaviours (Adferd)</li>
                            <li>Events (Hendelse)</li>
                        </ol>
                        <aside class="notes">
                            <p>Adferder og hendelser er to forskjellige kilder av informasjon som vi skal se på litt nærmere.</p>
                        </aside>
                    </section>
                    <section>
                        <h3>Adferder</h3>
                        <p>En kontinuerlig verdi. Eksemeplvis klokken, høyde eller vektorgrafikk.</p>

                        <aside class="notes">
                            <p>En adferd vil alltid ha en verdi. Det er noe som er kontinuerlig, og som er målbart.</p>
                            <p>Selv om en adferd har en kontinuerlig verdi kan den måles/observeres til å ha en spesifikk verdi.</p>
                            <p>F.eks selv om høyden min aldri ikke eksisterer (altså er kontinuerlig), kan jeg måle den på nåværende tidspunkt.</p>
                        </aside>
                    </section>
                    <section>
                        <h3>Hendelser</h3>
                        <p>En diskret verdi. Eksempelvis muse-klikk eller en mengde.</p>

                        <aside class="notes">
                            <p>Diskrete verdier eksisterer kun når de inntreffer, og i mellomtiden er det ikke eksisterende.</p>
                            <p>F.eks om en gjør et museklikk vil den ha en verdi (binært 1, i dette tilfellet) i det musen blir klikket, men i det den er ferdig-trykket, vil verdien slutte å eksistere.</p>
                        </aside>
                    </section>
                    <section>
                        <h3>I FRP blir adferder og hendelser behandlet som sekvenser og kan bli håndtert på en funksjonell måte.</h3>

                        <aside class="notes">
                            <p>F.eks med bruken av "map", "reduce" eller "filter".</p>
                            <p>Om man bruker "map" på en hendelse, vil et funksjonskall bli kalt på verdien hver gang hendelsen inntreffer. Utfallet etter map vil være en ny hendelse der verdien er transformert.</p>
                            <p>Om en f.eks bruker "filter", vil en få ut en hendelsessekvens som kun inneholder hendelser som oppfyller predikatet som er sendt inn i filter-kallet.</p>
                            <p>Med "reduce" vil det som bli returnert være en adferd, ettersom den da alltid vil ha verdier.</p>
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>FRP i frontend</h2>
                    </section>
                    <section>
                        <h3>Reaktivt</h3>
                        <p>Representasjon og oppdatering av elementer.</p>
                        <aside class="notes">Siden GUIer er naturlig tilstandsfulle trenger vi noe som kan representere den tilstanden og tillate oss å endre den. Reaktiv programmering gir oss datatyper for å representere elementene i GUIet vårt.

                        Den praktiske effekten av dette er at vi ikke trenger å manuelt endre tilstanden til elementer. Og vi får første-klasses datatyper til å representere elementer og forhold dem i mellom.</aside>
                    </section>
                    <section>
                        <h3>Funksjonelt</h3>
                        <p>Men med side-effekter</p>
                        <aside class="notes">Purely-functional tillater ikke side-effects. Men, siden vi benytter oss av reaktiv programmering så vil de reaktive data-typene håndtere side-effectene for oss slik at vi kan programmere i en funksjonell verden uten at side-effektene påvirker oss.

                        Dette gjør oss i stand til å benytte funksjonell programmering til å komponere forhold mellom GUI elementer og transformere data.</aside>
                    </section>
                    <section>
                        <h3>Deklarativt</h3>
                        <p>Spør heller hva enn hvordan</p>
                        <aside class="notes">Når vi kombinerer funksjonell og reaktiv programmering gir det oss muligheten til å gjøre koden deklarativ. V trenger ikke å gjøre noen manuelle side-effekter og kan derfor heller fokusere på hva vi ønsker å oppnå enn hvordan vi ønsker å oppnå det.

                        Dette gjør at vi bare trenger å assigne representasjonen av en adferd eller hendelse en gang. Hver gang vi lager en representasjon av enten en adferd eller hendelse eller en kombinasjon av flere så endrer vi ikke på den orginale representasjonen. Dette gjør oss i stand til å lage så mange representasjoner som vi har behov for.</aside>
                    </section>
                    <section>
                        <h3>Abstraksjoner</h3>
                        <p>Datatyper istedenfor innkapsling</p>
                        <aside class="notes">I Objekt Orientert kode er det vanlig å innkapsle funksjonalitet og tilstand. I FRP får vi heller førsteklasses reaktive datatyper med et api for funksjonell komposisjon og transformasjon. Fordelen med dette er at gjenbruk av kode blir enklere, fordi vi ikke har en intern tilstand og fordi vi ikke trenger å følge regler for forhold mellom innkapslinger, feks arv.</aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>Abstraksjonsammenligning: Backbone.js</h2>
                        <p>Models og Views</p>
                        <aside class="notes">Backbone er kanskje det rammeverket flest i BEKK kjenner til fra før. Det er også det rammeverket som har de enkleste og mest minimale abstraksjonene, som gjør det ganske passende for sammenligning med konseptene i FRP.

                        Kort sammendrag av Backbone's primære abstraksjoner for GUI; Models og Views. Models brukes for å representere tilstanden til data, mens Views brukes for å representere tilstanden til GUI. Forholdet mellom Model og View er løst koblet og krever en del manuell setup og boilerplate.</aside>
                    </section>
                    <section>
                        <h3>Representasjon av data</h3>
                        <p>Models vs Adferder</p>
                        <aside class="notes">I Backbone så representeres data som en modell. Den primære funksjonen til en modell her er å kunne abstrahere vekk intern tilstand og varsle om relevante endringer i intern tilstand. Den interne tilstanden er veldig fleksibel og Bacbone legger ingen føringer på det.

                        FRP representerer data som en adferd. For at FRP skal kunne representere data er man avengig av å ha en kilde som kan produsere data, feks ajax eller noe som representerer en konstant verdi. Adferder kan kombineres og på den måten kan du representere sammensatte data.

                        Siden en adferd alltid har en verdi kan man tilordne dem til et element og på den måten gjøre verdien synlig i grensesnittet. Og siden adferder er reaktive sørger det for at den synlige biten i grensesnittet alltid er oppdatert med verdien til adferden.

                        Ser man på APIet som eksponeres, så er det ikke så stor forskjell på de to abstraksjonene. Begge abstraksjonene kommuniserer ved hjelp av events, forskjellen ligger i hvordan events blir håndtert av mottaker. I FRP så vil den reaktive stilen sørge for at andre som avhenger av adferden oppdaterer seg selv, mens i Bacbone så må en håndtere det manuelt selv.</aside>
                    </section>
                    <section>
                        <h3>Representasjon av interaksjon</h3>
                        <p>View vs Hendelse</p>
                        <aside class="notes">Views i backbone er en innkapsling av funksjonalitet knyttet til en bit av grensesnittet. Koblingen mot GUIet er ganske løs og består hovedsaklig av event-lyttere og en template-funksjon som interpolerer data med markup. For å få avansert interaksjon kan man benytte en modell til å holde data eller ha en intern state i viewet.

                        Views kan kombineres ved nøsting for å innkapsle ytterligere og på den måten oppnå mer avansert funksjonalitet. Man har også mulighet for arv for å dele funksjonalitet, men arv har sine begrensninger og det kan føre til økt kompleksitet eller brudd på DRY.

                        I FRP så bruker man hendelser, diskrete hendelser i tid, til å representere de elementene som reagerer på interaksjon med grensesnittet. I FRP er det ikke hendelser som er direkte ansvarlig for å gjøre data synlig i grensesnittet, men hendelser kan fortsatt styre når eller hvordan oppdateringen skjer.

                        For å skape mer avansert interaksjon kan man i FRP komponere hendelser funksjonelt. At du hele tiden benytter deg av de reaktive datatypene gir deg en felles interface og at du ikke har noen intern tilstand i en hendelse gjør at du har mye friere tøyler når det kommer til gjenbruk av funksjonalitet.</aside>
                    </section>
                    <section>
                        <h3>Abstraksjonsammenligning</h3>
                        <p>Oppsummering</p>
                        <aside class="notes">FRP tilbyr minimale byggestener for å komponere mer avanserte strukturer for både interaksjon og data. Mens model og view legger seg på et høyre abstraksjonsnivå  og legger opp til mer manuell sammenkobling av GUI og kode. FRP er deklarativt, mens Model/View er imperativt.

                        Komposisjonsmulighetene er kanskje den største forskjellen mellom FRP og Model/View-abstraksjonen. I FRP gjør man funksjonell komponering. Fordi man har en universell interface i de reaktive datatypene kan man gjenbruke funksjoner på tvers av alt. I Model/View, som stort sett er objekt orientert, komponerer man ved å nøste (has-a) eller arve (is-a). Dette begrenser potensialet for gjenbruk til ting du kan utrykke med de forholdene.

                        That being said, det er egentlig ingenting i veien for å kombinere semantikken i Model/View abstraksjonen men en implementasjon som benytter seg av FRP. I bunn og grunn er View og Model bare innkapslinger av et sett med funksjonalitet som tilsammen utgjør en komponent.</aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>Abstraksjonsammenligning: Knockout.js</h2>
                        <p>ViewModel og View</p>
                        <aside class="notes">Knockout er et annet biblotek som gir abstraksjoner i samme gate som Backbone. Knockout er også ganske velkjent i BEKK og har den samme karakteristikken som Backbone at abstraksjonene er enkle og minimale. Det som gjør Knockout spesielt interessant i dette tilfellet er at det er laget for å gjøre GUI design deklarativt, akkurat som FRP.

                        Knockout har to sentrale komponenter, ViewModel og View. ViewModel er innkapsling av data og eksponering av et API for å konsumere data. View er en template med deklarative bindinger til en ViewModel.</aside>
                    </section>
                    <section>
                        <h3>Representasjon av data</h3>
                        <p>ViewModel vs Adferd</p>
                        <aside class="notes">ViewModels er, som Backbones Models, laget for å innkapsle data og gjøre dem tilgjengelige for konsum i applikasjonen. ViewModelen er den eneste komponenten i Knockout som har en intern tilstand. Alle tilstandsendringer i en Knockout-app går gjennom en ViewModel.

                        Det som muliggjør Knockouts deklarative tilnærming til GUI design er konseptet om observables. Observables er veldig like FRPs Adferder på den måten at de automatisk varsler de som avhenger av en selv. Knockouts

                        Observables kan også komponeres, på samme måte som FRPs Adferder, men ikke funksjonelt som i FRP. Og komposisjonsmulighetene er en del mer begrenset, siden du bare har ko.computed().

                        Avansert interaksjon foregår også til dels i ViewModels, i form av tilstandsendringer og enkle operasjoner, og tildels utenfor Knockout, i form av event-lyttere

                        Det er mulig å nøste ViewModels, og på den måten komponere mer komplekse ViewModels og beholde innkapsling. Gjenbruk på tvers av ViewModels gjøres ved å utvide base-typene med ny funksjonalitet.</aside>
                    </section>
                    <section>
                        <h3>Representasjon av interaksjon</h3>
                        <p>View vs Hendelse</p>
                        <aside class="notes">Et View i Knockout er egentlig en template med deklarative bindinger mot en underliggende ViewModel. Alle former for interaksjon vil derfor gå via ViewModel'en og dens observables.

                        Sammenlignet med Hendelser i FRP, som er obsverables i seg selv, så blir Views ganske stusslige. Hendelser gjør at man kan komponere avansert  interaksjon uten å måtte gå veien om den bakenforliggende ViewModel'en og samtidig beholde deklarativiteten.

                        Den kanskje største forskjellen på Hendelser og Views er at deklarativiteten lever i javascript kontra i templates, hvilket gir mye mer frihet og muligheter.</aside>
                    </section>
                    <section>
                        <h3>Abstraksjonsammenligning</h3>
                        <p>Oppsummering</p>
                        <aside class="notes">Til forskjell fra Backbone sammenligningen så er Knockouts abstraksjoner mye mer implementasjonsspesifike og det blir vanskelig å kombinere FRP med knockouts abstraksjoner.

                        Knockout deklarativitet gjør at det er mye mindre boilerplate og setup for å få ting til å henge sammen, men komposisjonsmulighetene er begrenset.</aside>
                    </section>
                </section>

                <section class="form-example">
                    <section>
                        <h2>Eksempel: Ufylling av skjema</h2>
                    </section>
                    <section>
                        <h3>Funksjonalitet i eksempelet</h3>
                        <ul>
                            <li>Fylle skjema med serverdata</li>
                            <li>Validere enkelt-inputs</li>
                            <li>Validere hele skjemaet</li>
                            <li>Sende tilbake til server</li>
                        </ul>
                    </section>
                </section>

                <section class="vote-example">
                    <section><h2>Eksempel med WebSockets og flere klienter.</h2></section>
                    <section><h3>Vi skal lage et enkelt system for spørreundersøkelser basert på WebSockets.</h3></section>
                    <section>
                        <pre><code data-trim>var socketStream =
    Bacon.fromEventTarget(socket, "vote")</code></pre>
                    </section>
                    <section>
                        <pre><code data-trim>var totalVoteProperty = function (id) {</code></pre>
                        <pre class="fragment"><code>    return socketStream</code></pre>
                        <pre class="fragment"><code>        .filter(_isId(id))</code></pre>
                        <pre class="fragment"><code>        .map(1)</code></pre>
                        <pre class="fragment"><code>        .scan(0, _add);</code></pre>
                        <pre><code>};</code></pre>
                    </section>

                    <section>

                        <pre><code data-trim>var percentage = function (stream, total) {</code></pre>
                        <pre><code class="fragment">    return stream</code></pre>
                        <pre><code class="fragment">            .combine(total, _toPercentage);</code></pre>
                        <pre><code data-trim>};</code></pre>
                    </section>

                    <section>
                        <pre><code data-trim>var sum = socketStream.map(1).scan(0, _add);</code></pre>
                    </section>

                    <section>
                        <pre><code data-trim>[1, 2, 3].forEach(function (id) {</code></pre>
                        <pre><code class="fragment" data-fragment-index="1">  return percentage(</code></pre>
                        <pre><code class="fragment" data-fragment-index="1">    totalVoteProperty("alt" + id), sum)</code></pre>
                        <pre><code class="fragment">        .assign($("#alt" + id), "val");</code></pre>
                        <pre><code data-trim>});</code></pre>
                    </section>

                    <section><h2>Demo</h2></section>

                    <section>
                        <h3>Her er det et spørsmål som er stilt, og det kan potensielt være langt?</h3>
                        <progress max="100" id="alt1" value="0" data-skill="Ett alternativ her" class="progress-red"></progress>
                        <progress max="100" id="alt2" value="0" data-skill="Et annet alternativ som er lengre" class="progress-yellow"></progress>
                        <progress max="100" id="alt3" value="0" data-skill="Noe slags opplegg her og..." class="progress-green"></progress>

                        <h4>Avgi din stemme på: <a href="#">bit.ly/NOEHER</a></h4>

                        <script>
                        (function () {
                            var socket = new io.connect(),
                                socketStream = Bacon.fromEventTarget(socket, "vote"),
                                _isId = function (id) {
                                    return function (data) {
                                        return data === id;
                                    };
                                },
                                _add = function (a, b) {
                                    return a + b;
                                },
                                _toPercentage = function (value, sum) {
                                    return sum === 0 ? 0 : (value / sum) * 100;
                                };

                            var totalVoteProperty = function (id) {
                                return socketStream.filter(_isId(id)).map(1).scan(0, _add);
                            };

                            var percentage = function (stream, total) {
                                return stream.combine(total, _toPercentage);
                            };

                            var sum = socketStream.map(1).scan(0, _add);

                            [1, 2, 3].forEach(function (id) {
                                percentage(totalVoteProperty("alt" + id), sum)
                                    .assign($("#alt" + id), "val");
                            });
                        }());
                        </script>
                    </section>
                </section>

                <section>
                    <section><h2>Takk for oss!</h2></section>
                    <section><h1>Spørsmål?</h1></section>

                </section>
            </div>

        </div>

        <script src="./lib/js/head.min.js"></script>
        <script src="./js/reveal.min.js"></script>

        <script>

            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; }},
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                    ]
            });

        </script>

    </body>
</html>
